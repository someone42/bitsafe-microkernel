/** \file kernel.h
  *
  * \brief Describes kernel functions.
  *
  * This file is licensed as described by the file LICENCE.
  */

#ifndef KERNEL_H_INCLUDED
#define KERNEL_H_INCLUDED

#include <stdint.h>
#include <stdbool.h>
#include "syscall.h"

/** Highest pre-emptive priority for a user thread. Cortex-M4F has 16 levels,
  * but the highest level is reserved for the kernel.
  * Note that smaller priority numbers mean higher priority. */
#define PRIORITY_HIGHEST        1
/** Lowest pre-emptive priority for a user thread. Cortex-M4F has 16 levels,
  * but the lowest level is reserved for the idle thread.
  * Note that bigger priority numbers mean lower priority. */
#define PRIORITY_LOWEST         14
/** Pre-emptive priority of the idle thread. */
#define PRIORITY_IDLE           15

/** Maximum number of IRQ numbers in STM32F4xx. stm32f4xx.h defines numbers
  * up to 81, so 128 gives us a bit of leeway. */
#define NUM_IRQ                 128
/** This is used mainly to do array bounds checks. */
#define KERNEL_ASSERT(x)        if (!(x)) {kernelFatalError();};

/** Kernel event object. This is exposed so that things outside of event.c
  * can create kernel events. */
typedef struct KernelEventStruct
{
    /** Whether event is set. */
    uint8_t is_set         : 1;
    /** Whether there's at least one thread waiting for the event to be set. */
    uint8_t thread_waiting : 1;
    /** Whether the event is auto-reset (true) or manual-reset (false). */
    uint8_t is_auto_reset  : 1;
    uint8_t padding        : 5; // align to byte boundary
} KernelEvent;

/** Kernel semaphore object. This is exposed so that things outside of
  * semaphore.c can create kernel semaphores. */
typedef struct KernelSemaphoreStruct
{
    /** Current count (wait = decrement, signal = increment) of semaphore. */
    int8_t count;
    /** Maximum (also initial) count of semaphore. */
    int8_t max;
    /** Event for threads to wait on, if semaphore has been waited on too
      * much. */
    KernelEvent wait_event;
} KernelSemaphore;

/** Value generated by kqueueOpen() which is used by the kernel queue functions
  * to refer to kernel queues. The actual structure is hidden in queue.c,
  * because only queue.c can create queues. The reason for this is that kernel
  * queues are for inter-process communication only; no-one else should need to
  * create queues. */
typedef uint32_t QueueHandle;

// Events
extern void keventInit(KernelEvent *event, bool auto_reset);
extern void keventWait(KernelEvent *event);
extern void keventSet(KernelEvent *event);
extern void keventReset(KernelEvent *event);

// Semaphores
extern KernelReturn ksemInit(KernelSemaphore *sem, int8_t in_max);
extern KernelReturn ksemSignal(KernelSemaphore *sem);
extern KernelReturn ksemWait(KernelSemaphore *sem);

// Scheduler
extern void kschedExitThread(void);
extern KernelReturn kschedCreateThread(void (*entry)(void *), uint32_t *stack, void *arg, uint8_t priority);
extern KernelReturn kschedSleep(uint32_t ticks);
extern void kschedWait(KernelEvent *event);
extern uint32_t kschedNotify(KernelEvent *event, bool all);
extern void kschedStart(void);

// Queues
extern KernelReturn kqueueOpen(uint8_t dest_process_id, QueueHandle *out_handle);
extern KernelReturn kqueueClose(QueueHandle handle);
extern KernelReturn kqueueWrite(QueueHandle handle, bool is_forward, uint8_t *data, uint32_t length, uint32_t *out_written);
extern KernelReturn kqueueRead(QueueHandle handle, bool is_forward, uint8_t *data, uint32_t size, uint32_t *out_read);

// Processes
extern void kprocessInit(void);
extern uint8_t kprocessGetCurrent(void);
extern void kprocessSwitchProcess(uint8_t process_id);
extern KernelReturn kprocessCall(uint8_t dest_process_id, QueueHandle transfer_queue);
extern KernelReturn kprocessHandleCall(uint8_t *source_process_id, QueueHandle *transfer_queue);
extern bool kprocessIsCurrentProcessIRQOwner(uint8_t irq);
extern uint8_t kprocessGetCurrentBasePriority(void);

// Interrupts
extern void kinterruptInit(void);
extern KernelReturn kinterruptWait(uint8_t irq);
extern KernelReturn kinterruptEnable(uint8_t irq);
extern KernelReturn kinterruptDisable(uint8_t irq);
extern KernelReturn kinterruptAcknowledge(uint8_t irq, bool is_level_sensitive);

// System calls
extern void ksyscallInit(void);

// Miscellaneous
extern void enterCriticalSection(void);
extern void leaveCriticalSection(void);
extern void kernelFatalError(void);

#endif // #ifndef KERNEL_H_INCLUDED
